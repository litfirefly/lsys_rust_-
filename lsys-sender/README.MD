##### 信息发送模块

> 功能实现中。。。。

> 对短信 邮件等对外发送信息进行二次封装 

> 目标及功能

1. 隔离应用对外部接口依赖
2. 发送日志跟发送效率保证
3. 常用发送方式的封装方便调用，如：验证码，批量广告，定时通知等



#### 流程图:

```mermaid
flowchart TB
    往Redis推送新增处理消息 -.-> 监听Redis列表
    subgraph worker-service[任务处理模块]
        任务处理channel发送端-->任务处理channel处理端-->读取任务消息-->完成任务处理channel处理
    end
    subgraph send-service[任务派发模块]
        监听Redis列表--有新增处理消息或监听超时-->清空Redis列表-->获取Redis读取数据锁定,并设置超时
        获取Redis读取数据锁定,并设置超时-->获取数据锁定成功
        获取Redis读取数据锁定,并设置超时-->获取数据锁定失败 --继续监听消息 -->监听Redis列表
        获取数据锁定成功-->获取运行任务结果集失败-->删除读取数据锁定1[删除读取数据锁定]
        获取数据锁定成功-->获取运行任务结果集为空或存在结果成功
        获取运行任务结果集为空或存在结果成功-->获取排除运行任务结果集后数据库的一批数据失败
        获取排除运行任务结果集后数据库的一批数据失败-->删除读取数据锁定1[删除读取数据锁定]-->监听Redis列表
        获取运行任务结果集为空或存在结果成功-->获取排除运行任务结果集后数据库的一批数据成功
        获取排除运行任务结果集后数据库的一批数据成功-->设置运行任务结果集+删除读取数据锁定失败-->监听Redis列表
        获取排除运行任务结果集后数据库的一批数据成功-->设置运行任务结果集+删除读取数据锁定成功
        设置运行任务结果集+删除读取数据锁定成功--数据库数据存在下一页-->往Redis推送继续处理消息-.->监听Redis列表
        设置运行任务结果集+删除读取数据锁定成功==把任务数据放入channel==>任务处理channel发送端
        完成任务处理channel处理==channel处理完成删除对应的运行任务结果集记录==>所有任务处理channel完成-->监听Redis列表
    end
    subgraph receive-service[接收任务模块]
    客户端请求新增-->存入数据库成功-->往Redis推送新增处理消息-->返回成功
    客户端请求新增-->存入数据库失败-->返回失败
    end
```

#### 运行任务结果集 的数据格式:

```
run-task[$task_id-num]=1//原子增
run-task[$task_id]={time:'任务开始',host:'任务所在主机'}
```

#### 配置

> 任务处理channel的大小

> 每次获取数据库记录数量,且`>=`任务处理channel的大小

